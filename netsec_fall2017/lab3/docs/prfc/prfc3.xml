<?xml version="1.0" encoding="US-ASCII"?>

<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml2rfc.ietf.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced. 
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2360 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2360.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml2rfc.ietf.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->




<rfc category="std" docName="rfc1" ipr="playgroundStd_v1_0" number="1">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902, playgroundWinter201501
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
   <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

   <title abbrev="PRFC's">People Enjoy Eavesdropping Protocol</title>

   <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

   <author fullname="Steven Ning Cheng" initials="S.N." role="editor"
           surname="Cheng">
     <organization>JHU Network Security Fall 2017</organization>

     <address>
       <postal>
         <street>John Hopkins University Graduate Lab </street>

         <!-- Reorder these if your country does things differently -->

         <city>Baltimore</city>

         <region>MD</region>

         <code>21218</code>

         <country>USA</country>
       </postal>

       <phone>+1 714-261-6147</phone>

       <email>stevencheng@jhu.edu</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

<author fullname="Jibraan Singh Chahal" initials="J.S.C" role="editor"
           surname="Chahal">
     <organization>JHU Network Security Fall 2017</organization>

     <address>
       <postal>
         <street>John Hopkins University Graduate Lab </street>

         <!-- Reorder these if your country does things differently -->

         <city>Baltimore</city>

         <region>MD</region>

         <code>21218</code>

         <country>USA</country>
       </postal>

       <phone>+1 443-525-2469</phone>

       <email>jchahal1@jhu.edu</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

<author fullname="Mengdi Yang" initials="M.D.Y" role="editor"
           surname="Yang">
     <organization>JHU Network Security Fall 2017</organization>

     <address>
       <postal>
         <street>John Hopkins University Graduate Lab </street>

         <!-- Reorder these if your country does things differently -->

         <city>Baltimore</city>

         <region>MD</region>

         <code>21218</code>

         <country>USA</country>
       </postal>

       <phone>+1 410-218-1481</phone>

       <email>myang51@jhu.edu</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

<author fullname="Suyi Liu" initials="S.Y.L" role="editor"
           surname="Liu">
     <organization>JHU Network Security Fall 2017</organization>

     <address>
       <postal>
         <street>John Hopkins University Graduate Lab </street>

         <!-- Reorder these if your country does things differently -->

         <city>Baltimore</city>

         <region>MD</region>

         <code>21218</code>

         <country>USA</country>
       </postal>

       <phone>+1 443-799-9993</phone>

       <email>sliu92@jhu.edu</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>
   <author fullname="Nan Ding" initials="N.D" role="editor"
           surname="Ding">
     <organization>JHU Network Security Fall 2017</organization>

     <address>
       <postal>
         <street>John Hopkins University Graduate Lab </street>

         <!-- Reorder these if your country does things differently -->

         <city>Baltimore</city>

         <region>MD</region>

         <code>21218</code>

         <country>USA</country>
       </postal>

       <phone>+1 443-525-5487</phone>

       <email>nding5@jhu.edu</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>


   <date year="2017" />

   <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
        in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>General</area>

   <workgroup>Playground Experiment Director</workgroup>

   <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>PLS</keyword>

   <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->
   <abstract>
     <t>This document specifies Version 1.0 of the Playground Layer Security (PLS) protocol. The PLS protocol similar to the Transport Layer Security (TLS) protocol and provides authentication, data confidentiality, and data integrity. PLS shall protect the communications between two hosts from eavesdropping, tampering, or message forgery.</t>	
     <t>This PRFC describes the specifications of the PLS protocol, including the functions to be implemented and the interfaces for users to utilize PLS.</t>
     <t>PLS relies on Playground, a tool allows developers to build their own networks, configure their own switches and VNICs (virtual network interface card), and build their own networking protocols.</t>
   </abstract>

 </front>

 <middle>

   <section title="Introduction">
     <t> The Playground Layer Security Protocol (PLS) provides a method to provide authentication, confidentiality, and data integrity for applications who wish to communicate across a network. The PLS layer is based on Players Enjoy Eavesdropping Protocol (PEEP) which allows the transmitted packet to be received orderly and correctly.  </t>
    <t>However, this protocol can be used in conjunction with different protocols, as long as the lower protocol guarantees that packets are delivered and are delivered in order.</t>
     <t>PLS provides security in the form of authentication, confidentiality, and integrity. We define these properties as follows:</t>
 <t><list style="numbers">
    	<t>Authentication: If host A wishes to communicate with host B, then both host A can verify that he is indeed communicating with host B and host B can verify that he is indeed communicating with host A. If there exists a host C pretending to be host A and communicate with host B, host B will be able to determine that an attacker is pretending to be host A and refuse communications with them.</t>
    	<t>Confidentiality: All data transmitted using PLS will be encrypted, preventing an attacker from gaining any meaningful information from intercepted packets. To the attacker, the data will look like random bits.</t>
           <t>Data Integrity: All data transmitted using PLS is tamper evident, preventing an attacker from altering transmitted data without the receiving host from noticing. If an attacker has attempted to alter the data sent between two hosts, the receiving host will know that the data has been tampered with.</t>
	    </list>
    </t>
    <t> The PLS protocol is used for encapsulation of various higher-level protocols. During the handshake process, the client and the server can authenticate each other and exchange the cryptographic keys before transmitting or receiving the data packets. The PLS protocol provides handshake security that consists of three basic properties:</t>
    <t><list style="numbers">
      <t>The identities of the peer can be verified using the certificates, asymmetric or public key, cryptography.</t>
      <t>The negotiation of pre-keys is secure: the pre-key is unavailable to eavesdroppers and for any authenticated connection, the pre-key is unique.</t>
      <t>The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the entities to the communication.</t>
     </list>
    </t>
    <t>This document describes the specifications of the PLS protocol, including elementary concepts, functions to be implemented and interfaces for users to utilize PLS protocol.</t>

<section title="Motivation and Scope">
<t>The PLS protocol has been developed as part of a course in Network Security at the Johns Hopkins University in order for us, as a class, to be able to understand current real-world measures and their weaknesses.
     </t>
     <t>This document focuses on the requirements and specifications of the Playground Layer Security protocol. Similar to the Transport Layer Security protocol [ RFC 5246], PLS provides provides authentication, confidentiality, and data integrity. PLS utilizes the Players Enjoy Eavesdropping Protocol, but can also utilize any protocol that provides reliable data transmissions, including the Transmission Control Protocol (TCP).
     </t>
     <t>PLS utilizes provably secure cryptographic methods such as AES-CTR symmetric key encryption, cryptographic hashes, and hash-based message authentication codes (HMAC).
     </t>
     <t>For use in the real world, PLS would lie in the session layer in the OSI model (figure 1) and utilize a reliable transport mechanism to guarantee authentication, confidentiality, and data integrity. 
     </t>
</section>
      

     <section title="About this Document">
       <t>This document presents a specification of the PLS implementation and the basic concepts behind PLS. Section 2 introduces the philosophical basis of the PLS design. Section 3 describes in detail the format of the packets used in PLS and how we achieve and guarantee authentication, confidentiality, and data integrity in the presence of malice.
	</t>
     </section>
   
   <section title="Interfaces and Operations">
<t>PLS lies in the middle of the application layer and the transport layer and provides a secure and reliable packet transmission mechanism for protocols at the application level. When an application wants to establish a private connection with another host, PLS will first verify identities, establish a secure session, then encrypt and transmit any data between the two hosts.
  </t>
  <t>To provide a secure network connection, this protocol includes mechanisms to ensure authentication, confidentiality, and data integrity.</t>
  <t>Authentication</t>
  <t>Using a trusted third party, hosts can verify the identities of the host it is communicating with through digitally signed certificates. Hosts will be able to trust that correctly signed certificates are proof that the identity to whom you are actually communicating with is the identity he claims to be. We will discuss certificates in more detail later.</t>
  <t>Confidentiality</t>
  <t>Data transmitted between two hosts are encrypted using the Advanced Encryption Standard (AES). This encryption mechanism has been proved to provide confidentiality and privacy, preventing an attacker from gathering any meaning from intercepted data.</t>
  <t>Integrity</t>
  <t>Data transmitted is verified using a message authentication code (MAC). We will use a hash-based message authentication code (HMAC) that is provably secure for data integrity. HMACs are generated by hashing a chunk of data and then using a key to encrypt it. </t>
  <t>These keys are only found on the two communicating hosts and are never transmitted over the network. If any data is found to be altered, the MAC will alert the host that the data has been indeed tampered with.</t>
  <t>Firstly, the PLS hosts will send hello messages to each other which contains a nonce and a certificate for authentication. Then, two entities will exchange the pre-key to generate other cryptographic keys for data encryption.</t>
  <t>To provide a reliable handshake process, the protocol guarantees three basic properties:</t>
  <t><list style="empty">
    <t>The identities of the peer can be verified using the certificates, asymmetric or public key, cryptography.</t>
    <t>The negotiation of pre-keys is secure: the pre-key is unavailable to eavesdroppers and for any authenticated connection, the pre-key is unique.</t>
    <t>The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the entities to the communication.</t>
  </list></t>

  <t>To provide a secure data transmission, the protocol ensures two properties:</t>
  <t><list style="empty">
    <t>The connection is private: All the data will be encrypted using symmetric cryptography such as AES. Each connection generates the keys for symmetric encryption uniquely, based on the pre-key exchanged in handshake process. So, the attacker could not get the data from encrypted packets.</t>
    <t>The connection is reliable: The MAC key is used for checking integrity of the message. we use the Security hash functions to compute the verification code. Any accidental corrupted packets or deliberately tampered packets will be discarded since the verification code does not match. It could prevent Man-in-the-Middle attack effectively.</t>
  </list></t>
   </section>

</section>





<section title="Philosophy">


<section title="Elements of the Network">
  <t>The Playground network environment allows hosts to establish connection to a switch through a VNIC. The switch is connected to other switches and other VNICs to simulate a real world network. Each VNIC can be created with an arbitrary playground address, which similar to an IPv4 address, has four parts, but each part can be an arbitrarily large number. Once this network is set up, hosts can communicate with other hosts through their VNIC addresses.</t>
  <t>At the moment, Playground operates similarly to a UDP transmission: a sender can send any kind of data to any host at any port. Playground itself provides to guarantees for data transfer and reliability. We have previously designed a protocol, Players Enjoy Eavesdropping Protocol (PEEP), to guarantee reliability and data delivery. PEEP provides no security whatsoever; this is why we need PLS.</t>
  <t>We define a packet as a standard used between a sender and a receiver to perform all the PLS operations. A packet will contain metadata and any data that one host wants to send to another host.</t>
</section>
  <section title="Relation to other Protocols">
    <t>The structure above shows the relation of PLS to other protocols. PLS will encrypt the data from application level and transfer the encrypted data to the lower layer. </t>
    <t>Since the lower layer provides guarantees ordered data delivery, PLS can be sure that data sent to the lower will be delivered to the other host. PLS can also be sure that any data received is correct and in order, which will then be decrypted and passed up to the application layer</t>
  </section>

  <section title="Secure Communications">
    <t>When transmitting application layer data, PLS will use symmetric encryption to encrypt application layer data and utilize an HMAC to verify data integrity. </t>
    <section title="Symmetric Encryption">
      <t>Because we are using symmetric encryption, specifically AES-CTR, there is no key exchange process. Both communicating hosts will be using the same key to encrypt and decrypt data, meaning the encryption key of the client is the decryption key of the server and vice versa.</t>
      <t>Keys will be generated in manner ensuring that both hosts can generate the same set of keys. </t>
      <t>When an application wishes to send data using PLS, the plaintext will be passed down to PLS. PLS will then encrypt the plaintext with the right key to produce a ciphertext and send the ciphertext to the other host. The receiving host will then extract the ciphertext, use the same key that encrypted the ciphertext to decrypt and produce the original plaintext. The plaintext will then be passed up to the application on the receiving host.</t>
      <t>In the PLS, all data is encrypted using AES-128 in CTR mode and the data sent must be encrypted with appropriate encryption key. In the AES CTR mode, the cipher text = [Encrypt(IV+i) XOR plain text]. The plain text = [Encrypt(IV+i) XOR cipher text</t>
      <t>For the client side, the encryption engine is configured with key EKc and IVc as the initial counter value and the decryption engine is configured with EKs as the key and IVs as the initial counter value. For the server side, the encryption engine is configured with key EKs and IVs as the initial counter value and the decryption engine is configured with EKc as the key and IVc as the initial counter value. </t>
      <t>The EKc, EKs, IVc and IVs are generated by the formula block_0=hash(PLS1.0"+Nc+Ns+PKc+PKs),block_1=hash(block_0), block_2=hash(block_1), block_3=hash(block_2),block_4=hash(block_3), block_5=hash(block_4). The five blocks is 800 bits in total, and the EKc is the first 128 bits, the Eks is the second 128 bits. And the IVc is the third 128 bits, the IVs is the fourth 128 bits.</t>
      <t>To send data, the plain text P is encrypted by the encryption engine to produce cipher text C.</t>

    </section>
    <section title="HMAC">
      <t>The PLS layer uses a keyed Message Authentication Code (MAC) to protect message integrity.  The cipher suites defined in this document use a construction known as HMAC, which is based on a hash function. Specifically, PLS will use SHA1 as the hash function in producing the HMAC.</t>
      <t>When sending data, the sending host who has produced a ciphertext will create an HMAC from and send it along with the ciphertext. The receiving host will then extract both the ciphertext and the sent HMAC. The receiving host will then verify that the HMAC is correct, proving that the ciphertext has not been altered.</t>
      <t>For the client, the MAC engine is configured with key MKc and the verification engine is configured with key MKs. For the server, the MAC engine is configured with key MKs and the verification engine is configured with key MKc. MKc is the fifth 128 bits of the 5 generated blocks. MKs is the sixth 128 bits of the generated blocks.</t>
      <t>To send data, the cipher text C is passed to MAC engine to produce verification code V. And data is send to another side as the format message(C,V). When data is received, the C is extracted and use the verification engine of the received side to produce V(prime). If the V(prime) is equal to V in the message, then the message could be used. If V(prime) is not equal to V, then the message is discarded and the received side will display False.</t>
    </section>
  </section>

  <section title="Authenticated Communications">
    <t>To provide authentication amongst two parties who wish to communicate, we rely on certificates.</t>
    <section title="Certificates">
    <t>Certificates are generated before any communications occur and are used as a mechanism to prove that the identity of the host is indeed the identity of the person you are intending to communicate with. </t>
    <t>Certificates in PLS are signed by a trusted third party. What this means is that the two hosts who wish to communicate rely on this trusted third party to ensure that there does not exist any fraudulent certificates who can claim an identity that they do not own.</t>
    <t>An example:</t>
    <t>Two hosts with addresses 20174.1.1.1 and 20174.1.2.2 wish to communicate with each other. These two hosts both own certificates that are signed and verified by a trusted third party. This signature can either be direct or indirect, namely the trusted third party can directly sign the certificate or transfer authority to another party to sign the certificate. When the two hosts begin communication, they will exchange certificates and effectively proving to each other that they are who they say they are.</t>
    <t>If the certificates transmitted are corrupt or identified to be fake in any way, then a host will cease all communications with the other host. </t>
    <t>At this point, it is up to the trusted third party to ensure that he is not signing any duplicate certificates, otherwise there will be two separate entities with the same identity, posing an obvious security risk.</t>

    </section>
  </section>

</section>






<section title="Functional Specifications">

<section title="PLS Packet Header Format">
<t> PLS packets are packets transferred between PLS layer, including session establishment, data packets, and close packets. We detail the specifications of PLS packets and the purpose of each packet field here.</t>
<section title="PlsHello">
 <t>     Nonce (8 bytes): 64 random bits of data used to prove freshness of a session. </t>
 <t>    Certs (List(Buffer)): a list of certificates required to verify the host. This will normally have 3 certificates. The certificate of the host, an intermediate CA certificate, and the root CA certificate. The list of certificates in this field must follow a hierarchy with the first certificate being the certificate of the host and the last certificate being the certificate of root CA. These certificates will be used to authenticate a host and assist in symmetric key establishment. 
</t>     
</section>     
                                     
<section title="PlsKeyExchange">
 <t>PreKey (Buffer): generated data used in the symmetric key establishment. This field will be encrypted with the public key of the host you are communicating with. The public key can be obtained from the certificate of the host in the first PlsHello message received and the encryption mechanism used is RSA-2048 with OAEP-SHA1 padding.</t>
<t>NoncePlusOne (UINT64): The received nonce plus one.</t>
</section>

<section title="PlsHandshakeDone">
<t>ValidationHash (BUFFER): A digested SHA1 hash of the previous exchanged messages. This will include two PlsHello packets and two PlsKeyExchange packets, with each host sending one PlsHello and one PlsKeyExchange packet. This validation hash is used to ensure that both communicating hosts have received the same information and both hosts can generate the same set of keys.</t>
</section>

<section title="PlsData">
<t>CipherText (BUFFER): Data passed down from the application and encrypted with the right keys. When receiving a PlsData packet, the CipherText will be decrypted with the hosts decryption key and be passed up to the receiving application layer.</t>
<t>Mac (BUFFER): the Mac is an HMAC and serves as a verification for the CipherText. The Mac is generated from the CipherText and the receiving host will verify the Mac with the CipherText before decrypting.</t>
</section>

 <section title="PlsClose">
 <t>Error (String Optional): if an error is detected, this Error field will contain a string describing the error. Presence of a PlsClose packet indicates abnormal termination. </t>
</section>

 </section>

<section title="State Machine">
<t>We have 5 states on each side: Init (1), Hello (2), KeyExch (3), HSDone (4), Secure (5)
Client side state machine:</t>	

<section title="Initial">
  <t>a. Start: Client Init state indicates that nothing has been sent yet, and client will be soon sending message m1 (Client Hello packet, the terminology of m1 to m6 will be discussed in details in establishing connection section)</t>
  <t>b.End: Client changes to Hello state after sending m1 </t>
</section>

<section title="Hello">
  <t>a.Start: Client sent m1 and waiting for m2 from server (Server Hello packet)</t>
  <t>b.End: Client changes to KeyExch after receiving m2 packet from server</t>
</section>

<section title="Key Exchange">
  <t>a.Start: Client received m2 sends m3 (Client PlsKeyExchange packet)</t>
  <t>b.End: Client changes to HSDone after receiving m4 packet from server</t>
				<t>Or</t>
  <t>c.Start: Client receives m2 and m4 and will send m3</t>
  <t>d.End: Client changes to HSDone after sending out m3</t>
  <t>There are two possibilities here because server sends m4 back to client as soon as it receives hello message of the client. Since sending m4 by the server does not depend on m3 of the client, client will either receive m4 before sending m3 or receive m4 after sending m3.</t>
</section>

<section title="Handshake Done">
<t>a.Start: Client received m4 and sent out m5 (Client PlsHandshakeDone packet)</t>
<t>b.End: Client received m6 from server (Server PlsHandshakeDone packet)</t>
<t>Or</t>
<t>c.Start: Client receives m6 will send m5</t>
<t>d.End: Client sent out m5 to server</t>
<t>Again, two possibilities exist here because client might receive m6 before sending out m5, or send out m5 before receiving m6. Since m3 and m4 does not depend on each other, the order of receiving m5 and sending out m6 is not determined.</t>
</section>

<section title="Secure">
<t>a.Start: Server finishes sending m6 and receiving m5</t>
<t>b.End: close() is called</t>
</section>

<section title="Close">
<t>a.The PLS connection is closed if close() is called. (Usually this is called when certificate cannot be verified or the MAC of the PlsData packet is not verified, or it received PlsClose packet from the other side)</t>
<t>Diagram of possible a state machine change scenario:</t>
 
</section>

</section>


<section title="Establishing Connection">
<t>The connection establishment follows the handshake protocol, where 6 messages: m1, m2, m3, m4, m5, m6 will be exchanged. </t>

<t>M1 is the client PlsHello packet sent to server. </t>
<t>M2 is the cerver PlsHello packet sent back to client. M2 depends on the receiving of m1.</t>
<t>M3 is the client PlsKeyExchange packet sent to server. M3 depends on the receiving of m2.</t>
<t>M4 is the server PlsKeyExchange packet sent back to client. M4 depends on the receiving of M1, but not necessarily on the receiving of m3.</t>
<t>M5 is the client PlsHandShakeDone packet sent to server. M5 depends on the receiving of m4.</t>
<t>M6 is the server PlsHandShakeDone packet sent back to client. M6 depends on the receiving of m3.</t>

<t>(m1 exchange) In the handshake protocol, the client first sends the Server a m1. nonce_c (Client Nonce) is a 64 bit random number. Client_certs is a list of certificates. The first certificate must be certificate of server, followed by any other certificates required for authentication. (m2 exchange) Then the server sends back a m2, where nonce_s (Server Nonce) is a 64-bit random number. Server_certs is a list of certificates. The first certificate must be certificate of server, followed by any other certificates required for authentication. (m3 exchange) Upon reception of m2, the Client sends the Server a key exchange message. The 128 bits-Client_pre_key is data that will be used by the client and the server to generate keys. nonce_s+1 is the nonce which server sent in m2 plus one. Client_pre_key is encrypted under the public key contained in certificate of server (the first certificate in Server_Certs). (m4 exchange) The server sends back m4, the key exchange message, right after it sends back m2 to client. The 128 bits-Server_pre_key is the data that will be used by the client and server to generate keys. nonce_c+1 is the Nonce sent in m1 plus one. Server_pre_key is encrypted under the public key contained in certificate of C (the first certificate in Client_Certs). Note that this message does not depend on the reception of m3, so m3 and m4 can be sent simultaneously. (m5 exchange) Upon receiving the key exchange message from the server, the client sends the server a handshake finished message. It contains the hash of the previous four messages m1 through m4. (m6 exchange) Similarly, as soon as m3 is received, the server sends the client a handshake finished message. It also contains the hash of the previous four messages m1 through m4. Specifically, it does not contain m5 in the hash, so this message can be sent immediately after receiving m3 from the client. </t>

<t>When the client and the server finish their exchange of m1 to m6, they can send PlsData packets over each other securely.</t>

<t>Four possible scenarios (Since m3, m4 can be sent simultaneously, and m5, m6 can be
sent simultaneously)</t>

<t>Scenario 1:</t>
<t>(M1 exchange) Client----- PlsHello(Nonce_c, [Client_Certs])---->Server</t>

<t>(M2 exchange) Client----PlsHello(Nonce_s, [Server_Certs])---Server</t>
<t>(M4 exchange) Client---PlsKeyExchange({Server_pre_key}Client_public_key, Nonce_c+1)----Server</t>
<t>(M3 exchange) Client---PlsKeyExchange({Client_pre_key}Server_public_key, Nonce_s+1)---->Server</t>
<t>(M5 exchange) Client----PlsHandshakeDone(SHA1(m1, m2, m3, m4) )--->Server</t>
<t>(M6 exchange) Client---PlsHandshakeDone(SHA1(m1, m2, m3, m4))----Server</t>
<t>... (Secure Data Transmission) ...</t>

<t>Scenario 2:</t>
<t>(M1 exchange) Client----- PlsHello(Nonce_c, [Client_Certs])---->Server</t>
<t>(M2 exchange) Client ---- PlsHello(Nonce_s, [Server_Certs])---Server</t>
<t>(M3 exchange) Client---PlsKeyExchange({Client_pre_key}Server_public_key, Nonce_s+1)---->Server</t>
<t>(M4 exchange) Client ---PlsKeyExchange({Server_pre_key}Client_public_key, Nonce_c+1)----Server</t>
<t>(M5 exchange) Client----PlsHandshakeDone(SHA1(m1, m2, m3, m4) )--->Server</t>
<t>(M6 exchange) Client ---PlsHandshakeDone(SHA1(m1, m2, m3, m4))----Server</t>
<t>... (Secure Data Transmission) ...</t>

<t>Scenario 3:</t>
<t>(M1 exchange) Client----- PlsHello(Nonce_c, [Client_Certs])---->Server</t>
<t>(M2 exchange) Client----PlsHello(Nonce_s, [Server_Certs])---Server</t>
<t>(M3 exchange) Client---PlsKeyExchange({Client_pre_key}Server_public_key, Nonce_s+1)---->Server</t>
<t>(M4 exchange) Client---PlsKeyExchange({Server_pre_key}Client_public_key, Nonce_c+1)----Server</t>
<t>(M6 exchange) Client---PlsHandshakeDone(SHA1(m1, m2, m3, m4))----Server</t>
<t>(M5 exchange) Client----PlsHandshakeDone(SHA1(m1, m2, m3, m4) )--->Server</t>
<t>... (Secure Data Transmission) ...</t>
<t>Scenario 4:</t>
<t>(M1 exchange) Client----- PlsHello(Nonce_c, [Client_Certs])---->Server</t>
<t>(M2 exchange) Client----PlsHello(Nonce_s, [Server_Certs])--->Server</t>
<t>(M4 exchange) Client---PlsKeyExchange({Server_pre_key}Client_public_key, Nonce_c+1)----Server</t>
<t>(M3 exchange) Client---PlsKeyExchange({Client_pre_key}Server_public_key, Nonce_s+1)---->Server</t>
<t>(M6 exchange) Client---PlsHandshakeDone(SHA1(m1, m2, m3, m4))----Server</t>
<t>(M5 exchange) Client----PlsHandshakeDone(SHA1(m1, m2, m3, m4) )--->Server</t>
<t>... (Secure Data Transmission) ...</t>
</section>
<section title="Closing Connection">
<t>If either client or server detects an error, it will send a PlsClose packet with an error message. The text of the error message is optional, but the presence of an error message indicates that it was not a normal termination.</t>
<t>Possible errors: </t>
	<t>In verifying the certificate chain when receiving a PlsHello packet: ip_subset is not valid, or issuer is not verified, or public_key contained in any certificate is invalid.</t>
	<t>In validating the hash received in the HandShakeDone packet, validation does not match with the own hash.</t>
	<t>In decrypting the preKey using the own private key when a PlsKeyExchange Packet is received, if there is an error occurring during the process, pls_close() will be called.</t>
	<t>In verifying the MAC of the packet when a PlsData Packet is received, if there is an error occurring during the process, pls_close() will be called.</t>

	<t>If connection is lost during any process (handshake/ data transmission), the PLS transport will be closed but no PlsClose packet is sent to the other side.</t>

	<t>If no error occurred and the connection is not lost during the process, the connection can still get closed when it wants to close the connection, by sending a PlsClose packet to the other side and close the PLS transport. Or it will close its PLS transportation when a PlsClose packet is received from the other side.</t>
</section>

<section title="Data Transmission">
<t>Since the lower PEEP layer ensures that data packets arrive in order reliably, PLS layer just makes sure each data packet is verified before passing it up, and makes sure each data packet is encrypted before sending out.</t>
<t>Passing up: Whenever a data packet is received, its mac is verified before it is passed to the higher protocol layer. If it fails to be verified, pls_close() is called and the connection gets terminated.</t>
<t>Sending out: Data is first encrypted by the AES-CTR mode encryptor, and mac is created by passing in the ciphertext we just got into the SHA1 hashing algorithm (discussed later in Symmetric Key Encryption section).</t>

</section>

<section title="Certificates">
<section title="Certificate Generation">
<t>Certificates will be used for authentication and assisting in key establishment. Certificates in PLS are generated in the X509 format and are required to be generated before any communication between 2 hosts begin. </t>

<t>Each host must generate a certificate with a valid playground address. Playground addresses have the format a.b.c.d where a, b, c, d can be any number between 0 and 65535. Certificates are considered valid if there exists a valid chain from the certificate of the host to a root certificate authority certificate. </t>

<t>At the moment, there only exists one root certificate authority that is Seth Nielson. Therefore, all certificates must be directly or indirectly signed by the certificate of Seth Nielson to be considered valid.</t>

</section>
<section title="Certificate verification">
<t>Certificate chain validation works by recursively validating 2 certificates until the last certificate in the chain. We must also verify that the last certificate is indeed a root CA certificate. At the time of writing, the only root CA certificate is the certificate of Seth Nielson.</t>

<t>For example:</t>
<t>Suppose there exists a certificate chain [A, B, C] that wishes to be validated. A, B, C represent certificates where B has signed A and C has signed B. To verify that B has indeed signed A, we extract the public key of B, signature of A, and the bytes of A excluding the signature. We then hash the bytes of A excluding the signature using SHA256 and decrypt signature of A using public key of B. If these two values match, then B did indeed sign A. </t>

<t>We proceed to perform this certificate verification on B and C, verifying that C did indeed sign B. Once this has been verified, we must also ensure that C is a root CA certificate.</t>

<t>If the chain has more than 3 certificates [C1, C2, ..., Cn] then certificate chain verification works by verifying certificate Ci with Ci+1 for values of i from 0 to n. Verifying Cn works by checking if Cn is a valid root CA certificate.</t>
</section>
</section>

<section title=" Symmetric Key Encryption">
<section title="Key Establishment">
<t>Key establishment occurs once a host has received the PlsHandshakeDone packet and verified the ValidationHash, but before the PLS layer notifies the above application layer that it is ready to receive data.</t>

<t>Because we are using symmetric key encryption, specifically AES-CTR, the client and the server must generate the same set of keys to properly encrypt and decrypt data of each other. In PLS, the key generation process combines the literal string=PLS1.0 and concatenates four items to it: the nonce Nc sent in the client PlsHello packet, the nonce Ns sent in the server PlsHello packet, PKc sent in the client PlsKeyExchange packet, and PKs sent in the server PlsKeyExchange packet. The values Nc, Ns, PKc, and PKs are in represented in raw bytes in a big-endian architecture and are to be appended in that order. The values PKc and PKs must also be decrypted before appending it to the string</t>

<t>Once the four values have been appended to the string=PLS1.0, we use this string as a seed and continually hash this string to produce the bits that will become our keys and initialization vectors. The hash algorithm PLS uses is SHA1 and the keys are produced as so:</t>
<t>SEED =PLS1.0 + Nc + Ns + PKc + PKs</t>
<t>block_0 = SHA1(SEED)</t>
<t>block_1 = SHA1(block_0)</t>
<t>block_2 = SHA1(block_1)</t>
<t>block_3 = SHA1(block_2)</t>
<t>block_4 = SHA1(block_3)</t>
<t>Each block produced is 160 bits long totaling 800 bits produced. We set our keys and initialization vectors as so:</t>
<t>EKc = total_bits[0:128]</t>
<t>EKs = total_bits[128:256]</t>
<t>MKc = total_bits[256:384]</t>
<t>MKs = total_bits[384:512]</t>
<t>IVc = total_bits[512:640]</t>
<t>IVs = total_bits[640:768]</t>
<t>where EKc is the client encrypting key and the decrypting key of the server, EKs is the encryption key of the server and the decrypting key of the client, MKc is the client MAC generation key and the server MAC verification key, MKs is the server MAC generation key and the client MAC verification key, IVc is the client initialization vector, and IVs is the server initialization vector.</t>
<t>Because each host has the same value for Nc, Ns, PKc, and PKs, we can be sure that both hosts have correct keys for encryption and decryption. Both hosts verify that they have received valid information by through the ValidationHash in the PlsHandshakeDone packet.</t>
</section>

<section title="Encryption">
<t>Encryption in PLS uses AES-CTR mode. This mode is chosen because it is very parallelizable and provides sufficient confidentiality.</t>
<t>The client performs encryption using EKc as the key and IVc as the initialization vector.</t>
<t>The server performs encryption using EKs as the key and IVs as the initialization vector.</t>
</section>

<section title="Decryption">
<t>Decryption in PLS uses AES-CTR mode.</t>
<t>The client performs decryption using EKs as the key and IVs as the initialization vector.</t>
<t>The server performs decryption using EKc as the key and IVc as the initialization vector.</t>
<t>The keys used to decrypt must be the same as the keys used to encrypt since we are using a symmetric key algorithm. That is why the decryption key used by the server is the same as the encryption key used by the client. In addition, because each host has the keys for both communicating hosts, proper encryption and decryption can be performed correctly so that the two hosts can communicate with confidentiality guaranteed.</t>
</section>

<section title="Message Authentication Codes (MAC)">
     <t>Message authentication codes ensure that the encrypted data in a PlsData packet has not been altered in any way.</t>
<t>Message authentication codes in PLS use the SHA1 hashing algorithm.
The bytes used as keys will be MKc and MKs as generated previously.</t>
<t>Message authentication codes in a PLSData packet are generated by using the HMAC algorithm for producing a hash-based message authentication code. The client will encrypt the ciphertext under MKc and the server will encrypt under MKs. </t>
<t>Message authentication codes in PLS are verified by using the HMAC algorithm for verifying a hash-based message authentication code. The client will decrypt using MKs and the server will decrypt using MKc.</t>
<t>Since both the client and the server have generated the same set of keys, namely MKc and MKs, they have the ability decrypt and verify the MAC.
</t>
</section>
</section>
<section title="Interfaces">
<t>There are two types of interfaces of concern. The application-PLS interface and the PLS-reliable transport interface. We will discuss both interfaces here.</t>
<t>Application-PLS Interface</t>
<t><list style="empty">
  <t>Open: The application level connection will only be opened once PLS has finished the handshake. This means that PLS has established a symmetric key with the communicating host and is ready to receive data from the application to encrypt and send to the communicating host. The PLS layer at the receiving host is also ready to receive data from the sending host for decryption to pass up to the application layer.</t>
  <t>Write: Whenever the application-level protocol wants to send data to another host, it will write data to the PLS and the data will be encrypted.</t>
  <t>Receive: When PLS receives data, it will check data integrity by verifying the MAC. Any packets that fail MAC verification will result in a packet drop. If the MAC verification succeeds, the received data will be decrypted and passed up to the application.</t>
  <t>Close: If the application has finished sending or wishes to disconnect, the PLS layer will stop sending data to the communicating host.</t>
</list></t>

<t>PLS-Reliable Transport Interface</t>
<t><list style="empty">
  <t>Open: Once a reliable transport has been established and has notified the PLS protocol of such establishment, then the PLS layer is ready to perform the PLS handshake and establish a symmetric key for secure communication.</t>
  <t>Write: Once the PLS layer has completed encryption of application data, it will pass the encrypted data to the reliable transport layer to be delivered to the communicating host.</t>
  <t>Receive: When the reliable transport receives data, it will ensure that the received data has been properly ordered. Once the reliable transport layer has organized received data in the correct order, it will pass up the data to the PLS layer.</t>
  <t>Close: Whenever the higher protocol closes the connection, the reliable transport layer will handle the closing request gracefully, waiting to resend data if necessary.</t>
</list>
</t></section>
<section title="Event Processing">
<t>The PLS is aimed to encrypt the data in the application level and then transfer the encrypted data to the lower level.  And PLS also decrypt data from the lower level and transfer the decrypted data to the higher level.</t>
<t>To encrypt and decrypt data, either side of the PLS level will have the handshake process first and then it can begin sending data process.</t>
<t>In the handshake process, the client and server side will first exchange the Nc(Client Nonce), C_Certs(Client Certs), Ns(Server Nonce) and S_Certs(Server Certs) in the hello message first. And then they will exchange the Pkc(Client Pre-Key) an Pks(Server Pre-Key) which are used to generate keys: Ekc, EKs, MKc, MKs. EKc is the client encryption key, EKs is the server encryption key which is the client decryption key, MKc is client MAC key and MKs is the server MAC key which is the client verification key. </t>
<t>The final step in the handshake process is to exchange the handshake finished message which contains the hash of the previous four messages M1 through M4. And client and server side will use the M1 to M4 to generate their own EKc, EKs, IVc, IVs, MKc and MKs separately. The process is shown below. </t>
<t><list style="numbers">
  <t>M1, C->S:  PlsHello(Nc,[C_Certs])</t>
  <t>M2, S->C:  PlsHello(Ns,[S_Certs])</t>
  <t>M3, C->S:  PlsKeyExchange({PKc}S_public, Ns+1)</t>
  <t>M4, S->C:  PlsKeyExchange({PKs}C_public, Nc+1)</t>
  <t>M5, C->S:  PlsHandshakeDone(Sha1(M1,M2,M3,M4))</t>
  <t>M6, S->C:  PlsHandshakeDone(Sha1(M1,M2,M3,M4))</t>
</list>
</t>
<t>The next process is data transfer process. For client side, EKc and IVc used for encrypting data, the EKs and IVs for decrypting data, the MAC engine is configured with key MKc and the verification is configured with key MKs. For server side, EKs and IVs used for encrypting data, EKc and IVc used for for decrypting data, the MAC engine is configured with key MKs and the verification is configured with key MKc.</t>

</section>
</section>

</middle>
 <!--  *****BACK MATTER ***** -->

 <back>
   <!-- References split into informative and normative -->

   <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")
    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

   <!--references title="Normative References"-->
     <!--?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
     <!--&RFC2119;-->
     
     <!--&RFC2360;-->
     
   <!--/references-->


   <!-- Change Log
v00 2006-03-15  EBD   Initial version	
v06 2010-04-01 TT     Changed ipr attribute values to latest ones. Changed date to
                     year only, to be consistent with the comments. Updated the 
                     IANA guidelines reference from the I-D to the finished RFC.  
                     
SETH NIELSON:
  Altered for PLAYGROUND AND PRFC's
  2016-09-21 SJN PRFC 1
  Updated for Fall 2017
  2017-10-1
  -->
 </back>
</rfc>
